
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code Comparison</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                background-color: #f4f4f4;
            }

            .code-container {
                display: flex;
                justify-content: space-between;
                margin-bottom: 20px;
            }

            .code-box {
                width: 32%;
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
            }

            .code-box pre {
                white-space: pre-wrap;
                background-color: #eee;
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
            }

            .explanation {
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
            }

        </style>
    </head>
  <body>
    <div class="code-container">
        <!-- Source Program -->
        <div class="code-box">
            <h2>Source Program</h2>
            <pre>
#include <iostream><br><br>#include <vector><br><br>#include <algorithm><br><br>#include <string><br><br>#include <map><br><br>#include <cmath><br><br>#include <queue><br><br>#include <numeric><br><br>#include <climits><br><br>#include <iterator><br><br>#include <iomanip><br><br>#include <stack><br><br>#include <bitset><br><br>#include <functional><br><br>using namespace std;<br><br>const constexpr int INF = 1e9;<br><br>//typedef std::pair<std::string,double> P;<br><br><br><br><br><br>#define FOR(i, a, n) for (ll i = (ll)a; i<(ll)n; ++i)<br><br>#define REP(i, n) FOR(i, 0, n)<br><br><br><br>typedef long long ll;<br><br>typedef vector<int> VI;<br><br>const constexpr ll MOD = 10000000000+7;<br><br>vector<pair<int, int> > vp;<br><br> <br><br>struct Less {<br><br>    bool operator()(const pair<int, int>& x, const pair<int, int>& y) const {<br><br>        return x.first > y.first;<br><br>    }<br><br>};<br><br><br><br>ll GCD(ll a, ll b){<br><br>    if(b==0) return a;<br><br>    return GCD(b, a%b);<br><br>}<br><br><br><br><br><br>//グラフの隣接リスト<br><br>VI g[200010];<br><br>//頂点の入次数を管理<br><br>int h[100010];<br><br>ll N, K;<br><br>string s;<br><br>ll v[51];<br><br><br><br>int main(void) {<br><br>    cin >> N >> K;<br><br>    <br><br>    ll cnt=0;<br><br>    if(K==0) cout << N*N << endl;<br><br>    else {<br><br>        for(ll i=K+1; i<=N; ++i){<br><br>        cnt += N/i*max(ll(0), i-K) + max(ll(0), N%i-K+1);<br><br>        }<br><br>        cout << cnt << endl;<br><br>    }<br><br>    <br><br>	return 0;<br><br>}
            </pre>
        </div>

        <!-- Generated Program -->
        <div class="code-box">
            <h2>Generated Program</h2>
            <pre>
Speedup over src: 34.401766378803245 <br>
#include <cstdio><br><br>typedef long long ll;<br><br>int main() {<br><br>    ll n, k; scanf("%lld%lld", &n, &k);<br><br>    ll ans = 0;<br><br>    for (ll b = k + 1; b <= n; ++b) {<br><br>        ans += (b - k) * (n / b);<br><br>        if (n % b >= k) ans += n % b - k + 1;<br><br>    }<br><br>    if (k == 0) ans -= n;<br><br>    printf("%lld\n", ans);<br><br>    return 0;<br><br>}
            </pre>
        </div>

        <!-- Target Program -->
        <div class="code-box">
            <h2>Target Program</h2>
            <pre>
Speedup over src: 6.513772279630463 <br>
#include <iostream><br><br>#include <vector><br><br>#include <algorithm><br><br>#include <string><br><br>using namespace std;<br><br>using ll = long long;<br><br>//西暦⇒時代の歴<br><br>ll a[100010];<br><br>int main()<br><br>{<br><br>    ll N, K;<br><br>    cin >> N >> K;<br><br><br><br>    if (K == 0)<br><br>    {<br><br>        cout << N * N << endl;<br><br>        return 0;<br><br>    }<br><br>    ll ans = 0;<br><br>    for (ll i = K + 1; i <= N; ++i)<br><br>    {<br><br>        // aは適当な数字に固定 b = i;<br><br>        ans += N / i * (i - K);<br><br>        ans += max(0LL, (N % i) - K + 1);<br><br>    }<br><br>    cout << ans << endl;<br><br>    return 0;<br><br>}
            </pre>
        </div>
    </div>
    
    <div class="explanation">
        <h3>Explanation of what the program does in natural language:</h3>
        <p>
This C++ program calculates and prints the number of pairs (x, y) where 1 ≤ x ≤ y ≤ N and (x mod y) ≥ K. Here, N and K are inputs provided by the user.

The program starts by reading the values of N and K from the standard input. If K is 0, it simply prints the square of N, because for every pair (x, y) where 1 ≤ x ≤ y ≤ N, (x mod y) will always be greater than or equal to 0.

If K is not 0, the program calculates the number of valid pairs (x, y) in a more complex way. It iterates over all possible values of y (from K+1 to N), and for each y, it calculates the number of x values that satisfy the condition (x mod y) ≥ K. This is done by adding up two quantities:

1. N/y * max(0, y-K): This represents the number of x values in each complete "cycle" of y values (from 0 to y-1) that satisfy the condition. There are N/y such cycles.

2. max(0, N%y-K+1): This represents the number of x values in the incomplete "cycle" (from 0 to N%y) that satisfy the condition.

Finally, the program prints the total count of valid pairs (x, y).
        </p>
    </div>
    

    <div class="explanation">
        <h3>Explanation of why the tgt program is faster than the source program:</h3>
        <p>
The optimization here is algorithmic. The optimized version of the program is faster because it removes unnecessary code and simplifies the operations.

The original program includes many unnecessary libraries and defines unused variables and functions. These extra lines of code can slow down the program because they consume memory and processing power. The optimized version of the program only includes the necessary libraries and defines only the variables that are actually used.

The algorithmic complexity of both the slow and fast programs is O(N). This is because both programs contain a loop that iterates from K+1 to N. However, the optimized program performs fewer operations inside the loop, which makes it faster.

Here are the optimizations that were made to the slow program to make it faster:

1. Removed unnecessary libraries: The slow program includes many libraries that are not used in the program. These libraries can slow down the program because they consume memory and processing power. The optimized program only includes the necessary libraries.

2. Removed unused variables and functions: The slow program defines many variables and functions that are not used in the program. These extra lines of code can slow down the program because they consume memory and processing power. The optimized program only defines the variables that are actually used.

3. Simplified operations: The slow program performs some unnecessary operations inside the loop. The optimized program simplifies these operations, which makes it faster.

4. Removed unnecessary comments: The slow program contains many comments that are not necessary for understanding the program. These comments can slow down the program because they consume memory. The optimized program removes these comments.

5. Used more efficient data types: The slow program uses the "long long" data type for some variables, which is less efficient than the "int" data type. The optimized program uses the "int" data type for these variables, which makes it faster.
        </p>
    </div>
    
    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the source program:</h3>
        <p>
The optimization here is primarily algorithmic, although there are also some minor changes that could contribute to the speedup.

The algorithmic complexity of both the slow and fast programs is O(N), where N is the input size. This is because both programs have a loop that iterates from K+1 to N. However, the constant factors in the time complexity are significantly reduced in the optimized version, leading to a faster execution time.

Here are the optimizations that were made to the slow program to make it faster:

1. **Algorithmic Optimization**: The optimized version simplifies the calculation of `cnt` (or `ans` in the optimized version). The slow version calculates `cnt` using two `max` operations and a multiplication inside the loop, while the optimized version simplifies this to a single multiplication and a conditional addition. This reduces the number of operations performed in each iteration of the loop, speeding up the program.

2. **Input/Output Optimization**: The slow version uses `cin` and `cout` for input and output, while the optimized version uses `scanf` and `printf`. The `scanf` and `printf` functions are generally faster than `cin` and `cout` in C++, so this change can also contribute to the speedup.

3. **Code Simplification**: The optimized version removes a lot of unnecessary code from the slow version. This includes the removal of unused `#include` directives, unused `typedef` declarations, unused constants, and an unused struct. While these changes don't directly affect the runtime of the program, they do make the code cleaner and easier to understand.

4. **Conditional Check Optimization**: In the optimized version, the check for `k == 0` is done after the loop, and it subtracts `n` from `ans` if `k` is 0. In the slow version, this check is done before the loop, and it outputs `N*N` and ends the program if `k` is 0. The optimized version's approach is faster because it avoids the need to perform a multiplication operation when `k` is 0.

Overall, the optimized version of the program is faster due to a combination of algorithmic optimization, input/output optimization, code simplification, and conditional check optimization.
        </p>
    </div>

    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the target program:</h3>
        <p>
The optimization here is not algorithmic, but rather due to the use of more efficient I/O functions and a slight change in the order of operations. The algorithmic complexity of both the slow and fast programs is O(N), as they both contain a single loop that iterates N times.

Here are the optimizations made:

1. I/O Functions: The slow program uses `cin` and `cout` for input and output, which are slower compared to `scanf` and `printf` used in the optimized program. This is because `cin` and `cout` have additional overhead due to synchronization with C's standard streams (`stdin` and `stdout`). `scanf` and `printf` are faster because they lack this synchronization.

2. Order of Operations: In the slow program, the condition `if (K == 0)` is checked before the loop. If `K` is 0, the program calculates `N * N` and ends. In the optimized program, this condition is checked after the loop, and if `K` is 0, `n` is subtracted from `ans`. This change doesn't affect the algorithmic complexity, but it does reduce the number of operations when `K` is 0, which could lead to a slight speedup.

3. Removal of Unused Variables and Includes: The optimized program removes the unused array `a` and the unused includes (`<vector>`, `<algorithm>`, and `<string>`), which reduces the memory footprint of the program.

4. Use of `typedef`: The optimized program uses `typedef` to define `ll` as `long long`, which is slightly faster to parse than the `using` directive used in the slow program.

In conclusion, the speedup is mainly due to the use of faster I/O functions and a slight reduction in the number of operations. The removal of unused variables and includes and the use of `typedef` also contribute to the speedup, but to a lesser extent.
        </p>
    </div>
</body>
    </html>
    