
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code Comparison</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                background-color: #f4f4f4;
            }

            .code-container {
                display: flex;
                justify-content: space-between;
                margin-bottom: 20px;
            }

            .code-box {
                width: 32%;
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
            }

            .code-box pre {
                white-space: pre-wrap;
                background-color: #eee;
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
            }

            .explanation {
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
            }

        </style>
    </head>
  <body>
    <div class="code-container">
        <!-- Source Program -->
        <div class="code-box">
            <h2>Source Program</h2>
            <pre>
#include <bits/stdc++.h><br><br>#define mem(x,v) memset(x,v,sizeof(x)) <br><br>#define go(i,a,b)  for (int i = a; i <= b; i++)<br><br>#define og(i,a,b)  for (int i = a; i >= b; i--)<br><br>#define MID(a,b) (a + b) >> 1<br><br>#define lson now << 1<br><br>#define rson now << 1 | 1<br><br>#define low(x) (x & (-x))<br><br>using namespace std;<br><br>typedef long long LL;<br><br>const double EPS = 1e-10;<br><br>const int INF = 1e9+100;<br><br>const int N = 1e6+10;<br><br>int a[N],b[N],c[N];<br><br>LL f[N];<br><br>int n,tt;<br><br>void Add(int x){<br><br>	while(x <= 3*n){<br><br>		f[x] += 1;<br><br>		x += low(x);<br><br>	}<br><br>}<br><br>int Query(int x){<br><br>	int ans = 0;<br><br>	while(x > 0) ans += f[x], x -= low(x);<br><br>	return ans; <br><br>}<br><br>bool find(int k){<br><br>	mem(f,0);<br><br>	LL Ans = 0;	b[0] = 0;<br><br>	go(i,1,n) if (a[i] >= c[k]) b[i] = b[i-1] + 1; else b[i] = b[i-1];<br><br>	go(i,0,n) {<br><br>		b[i] = 2*b[i] - i + n + 1;<br><br>		Ans += Query(b[i]);<br><br>		Add(b[i]);<br><br>	}<br><br>	LL t = (1LL * n * (n + 1)) / 2;<br><br>	if (Ans >= (t+1)/2) return 1; <br><br>	return 0;<br><br>}<br><br><br><br>int main(){<br><br>	scanf("%d",&n);<br><br>	int l = 1, r = n;<br><br>	go(i,1,n){<br><br>		scanf("%d",&a[i]);<br><br>		c[i] = a[i];<br><br>	}<br><br>	sort(c+1,c+n+1);<br><br>	int ans = 0;<br><br>	while(l <= r){<br><br>		int mid = MID(l,r);<br><br>		if (find(mid)) l = mid+1,ans = c[mid]; else r = mid - 1;<br><br>	}<br><br>	printf("%d\n",ans);<br><br>	return 0;<br><br>}
            </pre>
        </div>

        <!-- Generated Program -->
        <div class="code-box">
            <h2>Generated Program</h2>
            <pre>
Speedup over src: 50.05350583499421 <br>
#include<cstdio><br><br>#include<algorithm><br><br>#define N 1000005<br><br>using namespace std;<br><br>int n,a[N],b[N],sum,c[N];<br><br>int main()<br><br>{<br><br>	scanf("%d",&n);<br><br>	for(int i=1;i<=n;i++) scanf("%d",&a[i]);<br><br>	for(int i=1;i<=n;i++) c[i]=a[i];<br><br>	sort(c+1,c+n+1);<br><br>	int l=c[1],r=c[n];<br><br>	while(l<=r)<br><br>	{<br><br>		int mid=(l+r)>>1;<br><br>		b[0]=sum=0;<br><br>		for(int i=1;i<=n;i++)<br><br>		{<br><br>			if(a[i]>=mid) b[i]=b[i-1]+1;<br><br>			else b[i]=b[i-1];<br><br>			sum+=b[i]-(i-b[i]);<br><br>		}<br><br>		if(sum>(n*(n+1)/2)/2) l=mid+1;<br><br>		else r=mid-1;<br><br>	}<br><br>	printf("%d",l-1);<br><br>	return 0;<br><br>}
            </pre>
        </div>

        <!-- Target Program -->
        <div class="code-box">
            <h2>Target Program</h2>
            <pre>
Speedup over src: 9.330427423064723 <br>
#include <cstdio><br><br>#include <cstdlib><br><br>#include <cstring><br><br>#include <cmath><br><br>#include <algorithm><br><br>#include <iostream><br><br>#include <iomanip><br><br>#include <string><br><br>#include <vector><br><br>#include <queue><br><br>#include <map><br><br>#include <set><br><br><br><br>#define ll long long<br><br>#define ull unsigned long long<br><br>#define BUG printf("************\n")<br><br>using namespace std;<br><br><br><br>const ull mod = 1e8 + 7;<br><br>const int maxn = 4e5 + 10;<br><br>const int maxm = 1e6 + 10;<br><br>const double eps = 1e-8;<br><br><br><br>ll n, m;<br><br>ll a[maxn], b[maxn], s[maxn], f[maxn] ,c[maxn], r[maxn];<br><br><br><br>inline int lb(int x) {<br><br>    return x & -x;<br><br>}<br><br><br><br>void add(ll num, int x) {<br><br>    for (int i = x; i <= n; i+=lb(i))<br><br>        c[i] += num;<br><br>}<br><br><br><br>ll read(int x) {<br><br>    ll tot = 0;<br><br>    for (int i = x; i; i -= lb(i))tot += c[i];<br><br>    return tot;<br><br>}<br><br><br><br>const int cmp(const int i, const int j) {<br><br>    return f[j] == f[i] ? i < j : f[i] < f[j];<br><br>}<br><br><br><br>ll inversed_pair() {<br><br>    memset(c, 0, sizeof(c));<br><br>    for (int i = 1; i <= n; ++i)r[i] = i;<br><br>    sort(r + 1, r + 1 + n, cmp);<br><br>    ll tot = 0;<br><br>    for (int i = 1; i <= n; ++i) {<br><br>        tot += read(r[i]);<br><br>        add(1, r[i]);<br><br>    }<br><br>    return tot;<br><br>}<br><br><br><br>bool check(int x) {<br><br>    for (int i = 1; i <= n; ++i) {<br><br>        if (a[i] >= x)b[i] = 1;<br><br>        else b[i] = 0;<br><br>    }<br><br>    for (int i = 1; i <= n; ++i) {<br><br>        s[i] = s[i - 1] + b[i];<br><br>    }<br><br>    int t = 0;<br><br>    for (int i = 1; i <= n; ++i) {<br><br>        f[i] = 2 * s[i] - i;<br><br>        if (f[i] >= f[0])++t;<br><br>    }<br><br>    return (2 * (inversed_pair() + t) >= m);<br><br>}<br><br><br><br>int main() {<br><br>    ios::sync_with_stdio(0);<br><br>    cin.tie(0);<br><br>    cout.tie(0);<br><br>    cin >> n;<br><br>    for (int i = 1; i <= n; ++i) {<br><br>        cin >> a[i];<br><br>    }<br><br>    if (n == 1) {<br><br>        cout << a[1] << endl;<br><br>        return 0;<br><br>    }<br><br>    int l = 1, r = 1e9+10;<br><br>    m = (n + 1) * n / 2;<br><br>    while (l < r) {<br><br>        int mid = (l + r + 1) / 2;<br><br>        if (!check(mid))r = mid - 1;<br><br>        else l = mid;<br><br>    }<br><br>    cout << l << endl;<br><br>    return 0;<br><br>}<br><br>/*<br><br>9<br><br>7 12 4 18 3 16 18 5 9<br><br>*//*<br><br>10<br><br>16 18 12 17 15 8 10 9 16 4<br><br> */
            </pre>
        </div>
    </div>
    
    <div class="explanation">
        <h3>Explanation of what the program does in natural language:</h3>
        <p>
This C++ program is designed to find the median of an array of integers. The median is the value separating the higher half from the lower half of a data sample. If the data set has an odd number of observations, the number in the middle is the median. For data with an even number of observations, the median is the average of the two middle numbers.

Here's a step-by-step breakdown of what the program does:

1. The program starts by reading an integer `n` from the standard input, which represents the size of the array.

2. It then reads `n` integers into an array `a`.

3. The array `a` is copied into another array `c` and sorted.

4. The program then performs a binary search on the sorted array `c` to find the median. The binary search is done by repeatedly dividing the search interval in half. If the value of the search key is less than the item in the middle of the interval, the next interval will be the lower half. Otherwise, the next interval will be the upper half. The process repeats until the search key is found or the search interval is empty.

5. The `find` function is used to check if the current middle value is the median. It does this by creating a new array `b` where `b[i]` is the number of elements in `a[1..i]` that are greater or equal to `c[k]`. It then counts the number of pairs `(i, j)` such that `i < j` and `b[i] <= b[j]`. If this count is greater or equal to `n*(n+1)/2`, then `c[k]` is considered as a possible median.

6. The binary search ends when the search interval is empty. The last value that passed the `find` function is printed as the median.

This program uses a Fenwick tree (also known as a binary indexed tree) for efficient computation of the prefix sums in the `find` function. The Fenwick tree allows both the update operation and the prefix sum calculation to be done in O(log n) time, which makes it suitable for this program where these operations are done multiple times.
        </p>
    </div>
    

    <div class="explanation">
        <h3>Explanation of why the tgt program is faster than the source program:</h3>
        <p>
The optimization in the faster version of the program is primarily algorithmic. The faster version of the program has a more efficient approach to the problem, which reduces the time complexity of the program.

The slower version of the program has a time complexity of O(n^2) due to the nested loops in the `find` function. This means that the time taken by the program increases quadratically with the size of the input.

The faster version of the program, on the other hand, has a time complexity of O(n log n). This is because it uses a binary search in the main function and a Fenwick tree (also known as a Binary Indexed Tree) in the `check` function. Both of these algorithms have a time complexity of O(log n), and they are used in a loop that runs n times, resulting in a total time complexity of O(n log n). This means that the time taken by the program increases logarithmically with the size of the input, which is significantly faster for large inputs.

The optimizations made to the slow program to make it faster are as follows:

1. Algorithmic Optimization: The most significant optimization is the change in the algorithm used to solve the problem. The slow program uses a brute force approach with nested loops, while the fast program uses a binary search and a Fenwick tree, which are much more efficient.

2. Memory Optimization: The fast program uses an array `r` to store the indices of the array `f` in sorted order, which allows it to calculate the number of inversed pairs more efficiently. This reduces the amount of memory used by the program and also makes the program faster.

3. Code Optimization: The fast program uses inline functions and the `ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);` lines to speed up input and output. It also uses the `const int cmp(const int i, const int j)` function to sort the array `r`, which is faster than the `sort` function used in the slow program.

4. Conditional Optimization: The fast program uses the `check` function to determine whether a certain condition is met, and it stops the binary search as soon as this condition is met. This reduces the number of iterations in the binary search, which makes the program faster.
        </p>
    </div>
    
    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the source program:</h3>
        <p>
The optimization in the faster version of the program is primarily algorithmic. The original program has a time complexity of O(n log^2 n) due to the use of a binary search (O(log n)) and a Fenwick tree (also known as a Binary Indexed Tree) for prefix sum queries and updates (O(log n) per operation). The optimized version of the program has a time complexity of O(n log n) due to the use of a binary search (O(log n)) and prefix sum calculations (O(n)).

Here are the optimizations that were made to the slow program to make it faster:

1. Removal of Fenwick Tree: The Fenwick tree was used in the original program to calculate prefix sums. However, this is not necessary and can be replaced with a simple prefix sum calculation, which reduces the time complexity from O(log n) to O(1) per operation.

2. Simplification of Condition Checking: In the original program, the 'find' function was used to check a condition for each mid value in the binary search. This function was removed in the optimized program and the condition checking was simplified and integrated into the binary search loop.

3. Removal of Unnecessary Operations: The original program contained several unnecessary operations and function calls, such as the 'Add' and 'Query' functions, and the 'mem' macro for memory setting. These were removed in the optimized program.

4. Removal of Unnecessary Variables: The original program used several unnecessary variables, such as 'f', 'tt', and 'Ans'. These were removed in the optimized program.

5. Efficient Use of Memory: The optimized program uses less memory than the original program, as it does not need to store the Fenwick tree or the extra variables. This can also contribute to the speedup, especially if memory access is a bottleneck.

6. Efficient Use of I/O Operations: The optimized program uses scanf and printf for input and output, which are faster than cin and cout used in the original program. This can also contribute to the speedup, especially for large inputs and outputs.
        </p>
    </div>

    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the target program:</h3>
        <p>
The optimization in the faster version of the program is primarily algorithmic. The faster version simplifies the logic and reduces the number of operations, which leads to a significant speedup.

The slower version of the program has a time complexity of O(n^2) due to the inversed_pair() function, which contains a nested loop structure. This function is called inside the check() function, which is itself called inside a while loop in the main function. This leads to a high time complexity.

The faster version of the program has a time complexity of O(n log n) due to the sort operation. The rest of the operations in the main function are linear, leading to a much lower overall time complexity.

Here are the optimizations made to the slow program to make it faster:

1. Removed unnecessary functions: The slow version of the program contains several functions that are not necessary for the logic of the program. These include the lb(), add(), read(), and inversed_pair() functions. The faster version removes these functions and simplifies the logic.

2. Simplified logic: The slow version of the program uses a complex logic to calculate the sum and check the condition. The faster version simplifies this logic by directly calculating the sum in the main function.

3. Reduced number of operations: The slow version of the program performs a large number of operations, including addition, subtraction, and bitwise operations. The faster version reduces the number of operations by simplifying the logic.

4. Removed unnecessary data structures: The slow version of the program uses several arrays that are not necessary for the logic of the program. The faster version removes these arrays and uses only the necessary ones.

5. Optimized input/output operations: The faster version uses scanf and printf for input/output operations, which are faster than cin and cout used in the slower version.

6. Optimized the binary search: The faster version optimizes the binary search by using bitwise shift operations to calculate the mid value, which is faster than the division operation used in the slower version.
        </p>
    </div>
</body>
    </html>
    