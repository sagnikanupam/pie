
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Code Comparison</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                margin: 20px;
                background-color: #f4f4f4;
            }

            .code-container {
                display: flex;
                justify-content: space-between;
                margin-bottom: 20px;
            }

            .code-box {
                width: 32%;
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
            }

            .code-box pre {
                white-space: pre-wrap;
                background-color: #eee;
                padding: 10px;
                border-radius: 4px;
                overflow-x: auto;
            }

            .explanation {
                background-color: #ffffff;
                border: 1px solid #e0e0e0;
                padding: 10px;
                box-shadow: 1px 1px 5px rgba(0, 0, 0, 0.1);
                margin-bottom: 20px;
            }

        </style>
    </head>
  <body>
    <div class="code-container">
        <!-- Source Program -->
        <div class="code-box">
            <h2>Source Program</h2>
            <pre>
/*<br><br>Code By RyeCatcher<br><br>*/<br><br>#include <cstdio><br><br>#include <cstring><br><br>#include <cstdlib><br><br>#include <cctype><br><br>#include <iostream><br><br>#include <algorithm><br><br>#include <ext/pb_ds/hash_policy.hpp><br><br>#include <ext/pb_ds/assoc_container.hpp><br><br>#include <queue><br><br>#define ri register int <br><br>#define ll long long <br><br>#define ull unsigned long long <br><br>using std::min;<br><br>using std::max;<br><br>using std::lower_bound;<br><br>using namespace __gnu_pbds;<br><br>template <class T>inline void read(T &x){<br><br>    x=0;int ne=0;char c;<br><br>    while(!isdigit(c=getchar()))ne=c=='-';<br><br>    x=c-48;<br><br>    while(isdigit(c=getchar()))x=(x<<3)+(x<<1)+c-48;<br><br>    x=ne?-x:x;return ;<br><br>}<br><br>const int maxn=200005;<br><br>const int inf=0x7fffffff;<br><br>int n,nn,a[maxn],b[maxn],c[maxn],mx=-inf,mi=inf;<br><br>ll sum[maxn<<2];<br><br>inline void update(int x,int d){for(;x<=nn;x+=x&(-x))sum[x]+=d;}<br><br>inline ll query(int x){ll ans=0;for(;x;x-=x&(-x))ans+=sum[x];return ans;}<br><br>inline ll chk(int k){<br><br>    ll ans=0;<br><br>    b[0]=0;<br><br>    for(ri i=1;i<=n;i++){<br><br>        b[i]=b[i-1]+((a[i]<=k)?1:-1);<br><br>        c[i]=b[i];<br><br>        ans+=(b[i]>0);<br><br>    }<br><br>    std::sort(c+1,c+1+n);<br><br>    nn=std::unique(c+1,c+1+n)-(c+1);<br><br>    memset(sum,0,sizeof(sum));<br><br>    for(ri i=1;i<=n;i++){<br><br>    	b[i]=lower_bound(c+1,c+1+nn,b[i])-c;<br><br>        ans+=query(b[i]-1);<br><br>        update(b[i],1);<br><br>    }<br><br>    return ans;<br><br>}<br><br>int main(){<br><br>    read(n);<br><br>    for(ri i=1;i<=n;i++){<br><br>        read(a[i]);<br><br>        mi=min(mi,a[i]),mx=max(mx,a[i]);<br><br>    }<br><br>    int L=mi,R=mx,mid,ans;<br><br>	ll lim=1ll*n*(n+1)/4+1;//注意long long <br><br>    while(L<=R){<br><br>        mid=(L+R)>>1;<br><br>        if(chk(mid)>=lim)ans=mid,R=mid-1;<br><br>        else L=mid+1;<br><br>    }<br><br>    printf("%d\n",ans);<br><br>    return 0;<br><br>}
            </pre>
        </div>

        <!-- Generated Program -->
        <div class="code-box">
            <h2>Generated Program</h2>
            <pre>
Speedup over src: 41.58362974418764 <br>
#include<cstdio><br><br>#include<algorithm><br><br>#include<cctype><br><br>#include<cstring><br><br>#define Maxn 200000<br><br>#define LL long long<br><br>LL read(){<br><br>	LL x=0,f=1;char c=getchar();<br><br>	while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}<br><br>	while(isdigit(c)){x=x*10+c-'0'; c=getchar();}<br><br>	return x*f;<br><br>}<br><br>LL n,a[Maxn+5];<br><br>bool vis[Maxn+5];<br><br>int main(){<br><br>	n=read();<br><br>	LL sum=0;<br><br>	for(LL i=1;i<=n;i++)<br><br>	 sum+=(a[i]=read());<br><br>	std::sort(a+1,a+n+1);<br><br>	for(LL i=1;i<=n/2;i++) sum-=(a[i]<<1);<br><br>	printf("%lld\n",sum);<br><br>	return 0;<br><br>}
            </pre>
        </div>

        <!-- Target Program -->
        <div class="code-box">
            <h2>Target Program</h2>
            <pre>
Speedup over src: 4.288855227229357 <br>
#include<bits/stdc++.h><br><br>#define ll long long<br><br>#define max(a,b) ((a)>(b)?(a):(b))<br><br>#define min(a,b) ((a)<(b)?(a):(b))<br><br>#define swap(x,y) (x^=y^=x^=y)<br><br>inline int read()<br><br>{<br><br>	int x=0,f=1;char ch=getchar();<br><br>	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}<br><br>	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}<br><br>	return x*f;<br><br>}<br><br>#define MN 100005 <br><br>int n,m,a[MN],b[MN],c[MN];<br><br>int t[MN<<1];<br><br>void C(int x){for(;x<MN*2;x+=(x&-x))t[x]++;}<br><br>int G(int x){int res=0;for(;x;x-=(x&-x))res+=t[x];return res;}<br><br>inline bool check(int x)<br><br>{<br><br>	ll cnt=0ll;<br><br>	register int i;<br><br>	for(i=1;i<=n;++i) c[i]=c[i-1]+(a[i]>=x?1:-1);<br><br>	memset(t,0,sizeof t);<br><br>	for(i=1;i<=n;++i)<br><br>	{<br><br>		C(c[i-1]+MN);<br><br>		cnt+=G(c[i]+MN);<br><br>	}<br><br>	return cnt*4>=1ll*n*(n+1);<br><br>}<br><br>int main()<br><br>{<br><br>	n=read();register int i;<br><br>	for(i=1;i<=n;++i) a[i]=b[i]=read();<br><br>	std::sort(b+1,b+n+1);<br><br>	m=std::unique(b+1,b+n+1)-b-1;<br><br>	int l,r,ans;<br><br>	for(l=1,r=m,ans=0;l<=r;)<br><br>	{<br><br>		int mid=l+r>>1;<br><br>		if(check(b[mid])) ans=mid,l=mid+1;<br><br>		else r=mid-1;<br><br>	}<br><br>	printf("%d\n",b[ans]);<br><br>}
            </pre>
        </div>
    </div>
    
    <div class="explanation">
        <h3>Explanation of what the program does in natural language:</h3>
        <p>
This C++ program appears to be solving a problem related to array manipulation and searching. Here's a high-level overview of what it does:

1. The program starts by reading an integer `n` from the input, which represents the size of an array. Then, it reads `n` integers into the array `a`.

2. The program then calculates the minimum (`mi`) and maximum (`mx`) values in the array `a`.

3. The program then enters a binary search loop, where it calculates a midpoint `mid` between `mi` and `mx`. It uses this midpoint to call the function `chk`.

4. The `chk` function takes an integer `k` as an argument. It calculates a new array `b` based on `a`, where each element in `b` is the cumulative sum of 1s and -1s, depending on whether the corresponding element in `a` is less than or equal to `k`. It also calculates the number of positive elements in `b`.

5. The `chk` function then sorts the array `c` (which is a copy of `b`), removes duplicates from `c`, and updates `b` to contain the ranks of its elements in `c`. It also updates a Fenwick tree (represented by the array `sum`) based on the ranks in `b`, and calculates the cumulative sum of ranks in `b` that are less than the current rank.

6. The `chk` function returns the total sum calculated in the previous step plus the number of positive elements in `b`.

7. Back in the main function, if the result of `chk(mid)` is greater than or equal to a certain limit (which is calculated based on `n`), it updates `ans` to `mid` and continues the binary search with a smaller range. Otherwise, it continues the binary search with a larger range.

8. Finally, the program prints the value of `ans`, which is the maximum value that makes `chk(mid)` greater than or equal to the limit.

In summary, this program is finding a threshold value in an array such that when elements are converted to 1 or -1 based on this threshold, the sum of certain calculated values based on the converted array is maximized.
        </p>
    </div>
    

    <div class="explanation">
        <h3>Explanation of why the tgt program is faster than the source program:</h3>
        <p>
The optimization in the faster version of the program is primarily algorithmic. The faster version of the program has a more efficient approach to the problem, which reduces the time complexity of the program.

The slower version of the program has a time complexity of O(n^2 log n) due to the nested loop inside the chk function, which includes a sort operation. The faster version of the program has a time complexity of O(n log n) due to the removal of the nested loop and the more efficient use of the data structures.

Here are the optimizations that were made to the slow program to make it faster:

1. Removal of unnecessary libraries: The slower version of the program includes several libraries that are not used in the program. The faster version of the program only includes the necessary libraries, which reduces the overhead of the program.

2. Efficient use of data structures: The slower version of the program uses several arrays and a hash table, which increases the memory usage of the program. The faster version of the program uses fewer data structures, which reduces the memory usage of the program.

3. Algorithmic optimization: The slower version of the program uses a brute force approach to solve the problem, which results in a high time complexity. The faster version of the program uses a binary search approach, which reduces the time complexity of the program.

4. Inline functions: The faster version of the program uses inline functions for read, C, and G. Inline functions are a method of inserting the content of a function at the point where the function is called. If it's a small function, it can reduce the overhead of the function call, making the program faster.

5. Efficient use of variables: The faster version of the program uses fewer variables and makes more efficient use of them. This reduces the memory usage of the program and makes it faster.

6. Use of bitwise operations: The faster version of the program uses bitwise operations, which are faster than arithmetic operations. This makes the program faster.

7. Removal of unnecessary operations: The slower version of the program includes several operations that are not necessary to solve the problem. The faster version of the program removes these unnecessary operations, which makes the program faster.
        </p>
    </div>
    
    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the source program:</h3>
        <p>
The optimization here is primarily algorithmic. The original program has a higher time complexity due to the use of a binary search and a Fenwick tree (also known as a Binary Indexed Tree), while the optimized version simplifies the problem and reduces the time complexity significantly.

The original program has a time complexity of O(n log n) due to the binary search and the Fenwick tree operations. The binary search is used to find the minimum value that satisfies a certain condition, and for each value checked, it uses a Fenwick tree to calculate the number of elements that are less than or equal to this value. The Fenwick tree operations (update and query) have a time complexity of O(log n), so the overall time complexity is O(n log n).

The optimized version, on the other hand, has a time complexity of O(n log n) due to the sorting operation, but it doesn't have the additional log n factor from the Fenwick tree operations. It simply reads the input, sorts the array, and then calculates the difference between the sum of the larger half of the array and twice the sum of the smaller half. This is a much simpler and more efficient approach to solve the problem.

Here are the optimizations that were made to the original program:

1. Algorithmic optimization: The problem was simplified and solved in a more efficient way, without the need for a binary search or a Fenwick tree.

2. Input reading: The optimized version uses a simpler and more efficient function to read the input.

3. Memory usage: The optimized version doesn't use any additional arrays (like the b and c arrays in the original program), so it uses less memory.

4. Code simplification: The optimized version has less code and is easier to understand, which can also help to reduce the risk of bugs and improve the maintainability of the code.
        </p>
    </div>

    <div class="explanation">
        <h3>Explanation of why the generated program is faster than the target program:</h3>
        <p>
The optimization here is primarily algorithmic. The original program uses a more complex algorithm with a higher time complexity, while the optimized version simplifies the problem and reduces the time complexity significantly.

The original program has a time complexity of approximately O(n log n) due to the sorting operation and the binary search operation. The binary search operation is performed on the sorted array, and for each mid value, it checks whether it satisfies a certain condition. This check operation involves a loop over the entire array, which makes the overall time complexity O(n log n).

The optimized program also has a time complexity of O(n log n) due to the sorting operation. However, the subsequent operations only involve a single loop over the array, which makes the overall time complexity still O(n log n) but with a much smaller constant factor.

The optimizations made to the slow program to make it faster are as follows:

1. Algorithmic Simplification: The optimized program simplifies the problem by directly calculating the sum of the array elements and then subtracting twice the sum of the first half of the sorted array. This avoids the need for a binary search and a complex check operation.

2. Efficient I/O Operations: The optimized program uses getchar() and putchar() for input and output, which are faster than cin and cout in C++.

3. Reduced Memory Operations: The optimized program avoids unnecessary memory operations such as memset() in the original program.

4. Avoiding Unnecessary Computations: The optimized program avoids unnecessary computations such as the calculation of c[i] and the update and query of the binary indexed tree in the original program.

In summary, the optimized program is faster mainly due to the algorithmic simplification, which reduces the time complexity and avoids unnecessary computations and memory operations.
        </p>
    </div>
</body>
    </html>
    