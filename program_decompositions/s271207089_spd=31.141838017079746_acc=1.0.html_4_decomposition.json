{"optimized_code": "#include <cstdio>\n \n #include <cstring>\n \n #include <algorithm>\n \n #define ll long long\n \n #define MN 100005\n \n using namespace std;\n \n \n \n // Efficient input reading functions\n \n inline int read() {\n \n     int x = 0;\n \n     bool f = false;\n \n     char c = getchar();\n \n     while (c < '0' || c > '9') { \n \n         if (c == '-') f = true; \n \n         c = getchar(); \n \n     }\n \n     while (c >= '0' && c <= '9') { \n \n         x = x * 10 + (c - '0'); \n \n         c = getchar(); \n \n     }\n \n     return f ? -x : x;\n \n }\n \n \n \n inline ll readl() {\n \n     ll x = 0;\n \n     bool f = false;\n \n     char c = getchar();\n \n     while (c < '0' || c > '9') { \n \n         if (c == '-') f = true; \n \n         c = getchar(); \n \n     }\n \n     while (c >= '0' && c <= '9') { \n \n         x = x * 10 + (c - '0'); \n \n         c = getchar(); \n \n     }\n \n     return f ? -x : x;\n \n }\n \n \n \n int c_tree[200005], b_vals[MN];\n \n int a[MN];\n \n int n, tot, l, r, res;\n \n ll num;\n \n \n \n // Binary Indexed Tree operations\n \n inline void add(int x, int v){\n \n     while(x <= ((n << 1) | 1)){\n \n         c_tree[x] += v;\n \n         x += x & -x;\n \n     }\n \n }\n \n \n \n inline int query(int x){\n \n     int res = 0;\n \n     while(x > 0){\n \n         res += c_tree[x];\n \n         x -= x & -x;\n \n     }\n \n     return res;\n \n }\n \n \n \n // Optimized check function\n \n inline bool check(int x){\n \n     // Reset the Fenwick Tree\n \n     memset(c_tree, 0, sizeof(int) * ((n << 1) | 1) + 1);\n \n     add(n + 1, 1);\n \n     num = 0LL;\n \n     int sum = 0;\n \n     \n \n     for(int i = 1; i <= n; ++i){\n \n         sum += (a[i] > b_vals[x]);\n \n         int d_i = 2 * sum - i + n + 1;\n \n         if(d_i < 0) d_i = 0;\n \n         num += (ll)(query((n << 1) | 1) - query(d_i));\n \n         add(d_i, 1);\n \n     }\n \n     \n \n     return (num > ((ll)n * (n + 1)) / 4LL);\n \n }\n \n \n \n int main(){\n \n     n = read();\n \n     for(int i = 1; i <= n; ++i) \n \n         a[i] = b_vals[i] = read();\n \n     \n \n     sort(b_vals + 1, b_vals + n + 1);\n \n     tot = unique(b_vals + 1, b_vals + n + 1) - b_vals - 1;\n \n     \n \n     l = 0; \n \n     r = tot; \n \n     res = 0;\n \n     \n \n     while(l <= r){\n \n         int mid = (l + r) >> 1;\n \n         if(check(mid)){\n \n             res = mid;\n \n             r = mid - 1;\n \n         }\n \n         else{\n \n             l = mid + 1;\n \n         }\n \n     }\n \n     \n \n     printf(\"%d\", b_vals[res]);\n \n     return 0;\n \n }\n"}