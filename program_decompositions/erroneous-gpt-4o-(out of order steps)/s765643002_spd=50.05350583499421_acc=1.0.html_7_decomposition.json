{"optimized_code": "#include <bits/stdc++.h>\n\n#define mem(x, v) memset(x, v, sizeof(x))\n#define go(i, a, b) for (int i = a; i <= b; i++)\n#define MID(a, b) ((a + b) >> 1)\n#define low(x) (x & (-x))\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst double EPS = 1e-10;\nconst int INF = 1e9 + 100;\nconst int N = 1e6 + 10;\n\nint a[N], b[N], c[N], r[N];\nLL fen[N];  // Fenwick Tree array\nint n, tt;\n\ninline void Add(int x, int v) {\n    while (x <= 3 * n) {\n        fen[x] += v;\n        x += low(x);\n    }\n}\n\ninline LL Query(int x) {\n    LL ans = 0;\n    while (x > 0) ans += fen[x], x -= low(x);\n    return ans;\n}\n\ninline bool cmp(int i, int j) {\n    return b[i] < b[j];\n}\n\nbool find(int k) {\n    mem(fen, 0);  // Initialize Fenwick tree\n    LL Ans = 0;\n    b[0] = 0;\n    go(i, 1, n) if (a[i] >= c[k]) b[i] = b[i - 1] + 1; else b[i] = b[i - 1];\n    \n    // r array to store the sorted indices of b for the efficient comparison\n    iota(r, r + n + 1, 0);  // Initialize r with 0 to n\n    sort(r, r + n + 1, cmp);  // use the inline cmp function\n\n    // Prepare a compressed version of index\n    go(i, 0, n) b[r[i]] = i + 1; // Using r for indexing b\n    go(i, 0, n) {\n        Ans += Query(b[i] - 1); // Use negation to get inversions effectively\n        Add(b[i], 1);\n    }\n\n    LL t = (1LL * n * (n + 1)) / 2;\n    return Ans >= (t + 1) / 2;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    go(i, 1, n) {\n        cin >> a[i];\n        c[i] = a[i];\n    }\n    sort(c + 1, c + n + 1);\n\n    int l = 1, r = n, ans = 0;\n    while (l <= r) {\n        int mid = MID(l, r);\n        if (find(mid)) {\n            ans = c[mid];\n            l = mid + 1; // Proceed to find larger valid c[mid]\n        } else {\n            r = mid - 1;\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"}