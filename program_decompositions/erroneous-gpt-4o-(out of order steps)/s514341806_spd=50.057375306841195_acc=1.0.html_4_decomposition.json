{"optimized_code": "#include <bits/stdc++.h>\n\n#define mem(x,v) memset(x,v,sizeof(x)) \n\n#define go(i,a,b)  for (int i = a; i <= b; i++)\n\n#define og(i,a,b)  for (int i = a; i >= b; i--)\n\n#define MID(a,b) ((a) + (b)) >> 1\n\n#define lson (now << 1)\n\n#define rson ((now << 1) | 1)\n\n#define low(x) ((x) & (-(x)))\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst double EPS = 1e-10;\n\nconst int INF = 1e9+100;\n\nconst int N = 1e6+10;\n\nint a[N],b[N],c[N];\n\nLL f[N << 2];\n\nint n,tt;\n\nbool b_calculated = false;\nint last_k = -1;\n\nvoid Add(int x) {\n    while (x <= 4 * n) {\n        f[x] += 1;\n        x += low(x);\n    }\n}\n\nint Query(int x) {\n    int ans = 0;\n    while (x > 0) ans += f[x], x -= low(x);\n    return ans; \n}\n\nvoid calculate_b(int k) {\n    if (b_calculated && last_k == k) return;\n    b_calculated = true;\n    last_k = k;\n    b[0] = 0;\n    go(i,1,n) if (a[i] >= c[k]) b[i] = b[i-1] + 1; else b[i] = b[i-1];\n    go(i,0,n) b[i] = 2*b[i] - i + n + 1;\n}\n\nbool check(int k) {\n    calculate_b(k);\n    mem(f,0);\n    LL Ans = 0;\n    go(i,0,n) {\n        Ans += Query(b[i]);\n        Add(b[i]);\n    }\n    LL t = (1LL * n * (n + 1)) / 2;\n    return Ans >= (t+1)/2;\n}\n\nint main() {\n    scanf(\"%d\",&n);\n    go(i,1,n) {\n        scanf(\"%d\",&a[i]);\n        c[i] = a[i]; // Fill c array for later use\n    }\n    int min_c = *min_element(a + 1, a + n + 1);\n    int max_c = *max_element(a + 1, a + n + 1);\n    int l = min_c, r = max_c; // Update left and right to min and max of a\n    int ans = 0;\n    while (l <= r) {\n        int mid_value = MID(l,r);\n        auto it = lower_bound(c + 1, c + n + 1, mid_value);\n        int k = it - c; // Find the index equivalent in original sorted array\n        if (check(k)) l = mid_value + 1, ans = mid_value; else r = mid_value - 1;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"}