{"optimized_code": "#include <bits/stdc++.h>\n \n using namespace std;\n \n \n \n typedef long long LL;\n \n \n \n class FenwickTree {\n \n public:\n \n     FenwickTree(int size) : tree(size + 1, 0) {}\n \n     \n \n     void add(int index, LL value = 1) {\n \n         while (index < tree.size()) {\n \n             tree[index] += value;\n \n             index += index & -index;\n \n         }\n \n     }\n \n     \n \n     LL query(int index) const {\n \n         LL result = 0;\n \n         int i = index;\n \n         while (i > 0) {\n \n             result += tree[i];\n \n             i -= i & -i;\n \n         }\n \n         return result;\n \n     }\n \n     \n \n     void reset() {\n \n         fill(tree.begin(), tree.end(), 0);\n \n     }\n \n \n \n private:\n \n     vector<LL> tree;\n \n };\n \n \n \n class Solution {\n \n public:\n \n     void run() {\n \n         ios::sync_with_stdio(false);\n \n         cin.tie(nullptr);\n \n         \n \n         LL n;\n \n         cin >> n;\n \n         if(n == 1){\n \n             int single;\n \n             cin >> single;\n \n             cout << single << \"\\n\";\n \n             return;\n \n         }\n \n         vector<int> a(n + 1);\n \n         for (LL i = 1; i <= n; ++i) {\n \n             cin >> a[i];\n \n         }\n \n         \n \n         LL left = 1, right = 1000000010; // 1e9 + 10\n \n         while (left < right) {\n \n             LL mid = left + (right - left + 1) / 2;\n \n             if (check(mid, a, n)) {\n \n                 left = mid;\n \n             } else {\n \n                 right = mid - 1;\n \n             }\n \n         }\n \n         \n \n         LL ans = left;\n \n         cout << ans << \"\\n\";\n \n     }\n \n \n \n private:\n \n     bool check(LL threshold, const vector<int>& a, LL n) {\n \n         vector<long long> b(n + 1, 0);\n \n         for (LL i = 1; i <= n; ++i) {\n \n             b[i] = (a[i] >= threshold) ? b[i - 1] + 1 : b[i - 1];\n \n         }\n \n         \n \n         // Transform b[i] to r_sorted[i]\n \n         vector<long long> r_sorted(n + 1);\n \n         for (LL i = 0; i <= n; ++i) {\n \n             r_sorted[i] = 2 * b[i] - i + n + 1;\n \n         }\n \n         \n \n         // Coordinate compression\n \n         sort(r_sorted.begin(), r_sorted.end());\n \n         r_sorted.erase(unique(r_sorted.begin(), r_sorted.end()), r_sorted.end());\n \n         int unique_size = r_sorted.size();\n \n         \n \n         // Replace b[i] with their ranks\n \n         vector<int> ranked_b(n + 1);\n \n         for (LL i = 0; i <= n; ++i) {\n \n             ranked_b[i] = lower_bound(r_sorted.begin(), r_sorted.end(), r_sorted[i]) - r_sorted.begin() + 1;\n \n         }\n \n         \n \n         LL total_pairs = (n * (n + 1)) / 2;\n \n         LL target = (total_pairs + 1) / 2;\n \n         \n \n         return inversed_pair(ranked_b, n, unique_size, target);\n \n     }\n \n     \n \n     bool inversed_pair(const vector<int>& b_arr, LL size, int unique_size, LL target) {\n \n         FenwickTree fenwick(unique_size);\n \n         LL Ans = 0;\n \n         for (LL i = 0; i <= size; ++i) {\n \n             Ans += fenwick.query(b_arr[i]);\n \n             if (Ans >= target) {\n \n                 return true;\n \n             }\n \n             fenwick.add(b_arr[i]);\n \n         }\n \n         return Ans >= target;\n \n     }\n \n };\n \n \n \n int main(){\n \n     Solution solution;\n \n     solution.run();\n \n     return 0;\n \n }\n"}