{"optimized_code": "#include <bits/stdc++.h>\n\n#define mem(x,v) memset(x,v,sizeof(x))\n\n#define go(i,a,b) for (int i = a; i <= b; i++)\n\n#define og(i,a,b) for (int i = a; i >= b; i--)\n\n#define MID(a,b) (((a) + (b)) >> 1)\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst double EPS = 1e-10;\n\nconst int INF = 1e9+100;\n\nconst int N = 1e6+10;\n\nint a[N];\nint fenwick_tree[3*N+1];\n\nint n, tt;\n\ninline void fenwick_update(int x, int delta) {\n while(x <= 3 * n) {\n fenwick_tree[x] += delta;\n x += (x & -x);\n }\n}\n\ninline int fenwick_query(int x) {\n int sum = 0;\n while(x > 0) {\n sum += fenwick_tree[x];\n x -= (x & -x);\n }\n return sum;\n}\n\nbool find(int k, int threshold) {\n mem(fenwick_tree, 0);\n LL Ans = 0;\n int b = 0;\n vector<pair<int, int>> events(n + 1); // Pair to store values and their indices\n go(i, 1, n) {\n b += (a[i] >= threshold) ? 1 : 0;\n int b_transformed = 2 * b - i + n + 1;\n events[i] = {b_transformed, i}; // Store value and its index\n }\n // Sort by first element in pair (b[i])\n sort(events.begin() + 1, events.begin() + n + 1);\n go(i, 1, n) {\n int idx = events[i].second;\n Ans += fenwick_query(idx);\n fenwick_update(idx + 1, 1);\n }\n LL t = (1LL * n * (n + 1)) / 2;\n return Ans >= (t + 1) / 2;\n}\n\nint main() {\n ios::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n\n cin >> n;\n vector<int> c(n);\n go(i, 1, n){\n cin >> a[i];\n c[i-1] = a[i];\n }\n sort(c.begin(), c.end());\n int l = 0, r = n - 1;\n int ans = 0;\n while(l <= r) {\n int mid_idx = l + (r - l) / 2; // Use revised logic for mid calculation\n if (find(mid_idx, c[mid_idx])) {\n ans = c[mid_idx];\n l = mid_idx + 1; // Move l beyond current mid_idx\n } else {\n r = mid_idx - 1; // Move r before current mid_idx\n }\n }\n cout << ans << '\\n';\n return 0;\n}"}