{"optimized_code": "/*\n \n Code By OptimizedProgrammer\n \n */\n \n #include <bits/stdc++.h>\n \n \n \n using namespace std;\n \n typedef long long ll;\n \n \n \n // Fast input\n \n inline void read(int &x){\n \n     x = 0; int ne = 0; char c;\n \n     while(!isdigit(c = getchar()) && c != '-');\n \n     if(c == '-') { ne = 1; c = getchar(); }\n \n     x = c - '0';\n \n     while(isdigit(c = getchar())) x = x * 10 + c - '0';\n \n     if(ne) x = -x;\n \n }\n \n \n \n int main(){\n \n     ios::sync_with_stdio(false);\n \n     cin.tie(0);\n \n     \n \n     int n, mi = INT32_MAX, mx = INT32_MIN;\n \n     read(n);\n \n     vector<int> a(n);\n \n     for(auto &x : a){\n \n         read(x);\n \n         mi = min(mi, x);\n \n         mx = max(mx, x);\n \n     }\n \n \n \n     // Lambda for checking\n \n     auto chk = [&](int k) -> ll {\n \n         vector<int> prefix(n + 1, 0);\n \n         for(int i = 0; i < n; i++) prefix[i+1] = prefix[i] + (a[i] <= k ? 1 : -1);\n \n \n \n         // Coordinate compression\n \n         vector<int> sorted = prefix;\n \n         sort(sorted.begin(), sorted.end());\n \n         sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n \n         int size = sorted.size();\n \n \n \n         // Initialize BIT\n \n         vector<int> bit(size + 1, 0);\n \n         auto update = [&](auto &update_ref, int idx) -> void {\n \n             while(idx <= size){\n \n                 bit[idx]++;\n \n                 idx += idx & -idx;\n \n             }\n \n         };\n \n         auto query = [&](auto &query_ref, int idx) -> ll {\n \n             ll res = 0;\n \n             while(idx > 0){\n \n                 res += bit[idx];\n \n                 idx -= idx & -idx;\n \n             }\n \n             return res;\n \n         };\n \n         \n \n         ll ans = 0;\n \n         int mapped = lower_bound(sorted.begin(), sorted.end(), prefix[0]) - sorted.begin() + 1;\n \n         update(update, mapped);\n \n \n \n         for(int i = 1; i <= n; i++){\n \n             mapped = lower_bound(sorted.begin(), sorted.end(), prefix[i]) - sorted.begin() + 1;\n \n             ans += query(query, mapped - 1);\n \n             update(update, mapped);\n \n         }\n \n         return ans;\n \n     };\n \n \n \n     ll lim = 1LL * n * (n + 1) / 4 + 1;\n \n     int L = mi, R = mx, ans_val = mx;\n \n     while(L <= R){\n \n         int mid = L + (R - L) / 2;\n \n         if(chk(mid) >= lim){\n \n             ans_val = mid;\n \n             R = mid - 1;\n \n         }\n \n         else{\n \n             L = mid + 1;\n \n         }\n \n     }\n \n     printf(\"%d\\n\", ans_val);\n \n     return 0;\n \n }\n"}