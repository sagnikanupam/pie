{"optimized_code": "#include <bits/stdc++.h>\n\n#define mem(x,v) memset(x,v,sizeof(x))\n#define go(i,a,b)  for (int i = a; i <= b; i++)\n#define og(i,a,b)  for (int i = a; i >= b; i--)\n#define MID(a,b) (a + b) >> 1\n#define low(x) (x & (-x))\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 1e6+10;\n\nint a[N], c[N], r[N];\n\nLL f[N];\n\nint n;\n\ninline void Add(int x){\n    while(x <= 3*n){\n        f[x] += 1;\n        x += low(x);\n    }\n}\n\ninline int Query(int x){\n    int ans = 0;\n    while(x > 0) ans += f[x], x -= low(x);\n    return ans;\n}\n\nbool check(int mid){\n    mem(f, 0);\n    LL Ans = 0;\n    int b[N];\n    b[0] = 0;\n    go(i, 1, n) {\n        b[i] = b[i - 1] + (a[i] >= c[mid] ? 1 : 0);\n    }\n    go(i, 0, n) {\n        b[i] = 2*b[i] - i + n + 1;\n        r[b[i]] = i;  // Store the indices in sorted order\n        Ans += Query(b[i]);\n        Add(b[i]);\n    }\n    \n    // Calculate Ans using the pre-stored indices\n    for(int i = 0; i <= n; i++) {\n        if (r[b[i]] > 0) \n            Ans += Query(b[r[b[i]]]);\n    }\n    \n    LL t = (1LL * n * (n + 1)) / 2;\n    return Ans >= (t + 1) / 2;\n}\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    scanf(\"%d\", &n);\n    go(i, 1, n) {\n        scanf(\"%d\", &a[i]);\n        c[i] = a[i];\n    }\n    sort(c + 1, c + n + 1);\n    int l = 1, r = n, ans = 0;\n    while(l <= r){\n        int mid = MID(l,r);\n        if (check(mid)) {\n            ans = c[mid];\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"}