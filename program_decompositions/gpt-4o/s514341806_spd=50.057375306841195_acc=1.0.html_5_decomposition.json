{"optimized_code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nconst double EPS = 1e-10;\nconst int INF = 1e9 + 100;\nconst int N = 1e6 + 10;\n\nint a[N], b[N];\nLL f[4 * N];\nint n, tt;\n\nbool check(int k) {\n    static int prev_k = -1; // Variable to keep track of the last k value\n    static bool recalculated = false; // Keep track of recalculation necessity\n    \n    if (k != prev_k) {\n        memset(f, 0, sizeof(f));\n        b[0] = 0;\n        prev_k = k;\n        recalculated = false;\n    }\n\n    if (!recalculated) {\n        for (int i = 1; i <= n; i++) b[i] = (a[i] >= k) ? b[i-1] + 1 : b[i-1];\n\n        for (int i = 0; i <= n; i++) {\n            b[i] = 2 * b[i] - i + n + 1;\n            f[0] += Query(b[i]);\n            Add(b[i]);\n        }\n\n        recalculated = true;\n    }\n\n    LL t = (1LL * n * (n + 1)) / 2;\n    return f[0] >= (t + 1) / 2;\n}\n\nvoid Add(int x) {\n    while (x <= 4 * n) {\n        f[x] += 1;\n        x += (x & -x);\n    }\n}\n\nint Query(int x) {\n    int ans = 0;\n    while (x > 0) ans += f[x], x -= (x & -x);\n    return ans; \n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int l = INF, r = -INF;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        l = min(l, a[i]);\n        r = max(r, a[i]);\n    }\n    \n    int ans = 0;\n    while (l <= r) {\n        int mid = (l + r) / 2;\n        if (check(mid)) l = mid + 1, ans = mid; else r = mid - 1;\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}"}