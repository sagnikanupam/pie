{"optimized_code": "#include <bits/stdc++.h>\n\n#define mem(x,v) memset(x,v,sizeof(x))\n\n#define go(i,a,b) for (int i = a; i <= b; i++)\n\n#define og(i,a,b) for (int i = a; i >= b; i--)\n\n#define MID(a,b) ((a) + (b)) >> 1\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst double EPS = 1e-10;\n\nconst int INF = 1e9+100;\n\nconst int N = 1e6+10;\n\nint a[N], b[N], c[N];\n\nint fenwick_tree[3*N+1];\n\nint n, tt;\n\ninline void fenwick_update(int x, int delta) {\n while(x <= 3 * n) {\n fenwick_tree[x] += delta;\n x += (x & -x);\n }\n}\n\ninline int fenwick_query(int x) {\n int sum = 0;\n while(x > 0) {\n sum += fenwick_tree[x];\n x -= (x & -x);\n }\n return sum;\n}\n\n// Comparator function for sorting\ninline bool cmp(int i, int j) {\n return b[i] < b[j];\n}\n\nbool find(int k) {\n mem(fenwick_tree, 0);\n LL Ans = 0;\n b[0] = 0;\n vector<int> r(n + 2); // Optimization: Array 'r' for sorted indices\n go(i, 1, n) {\n if (a[i] >= c[k]) b[i] = b[i-1] + 1; \n else b[i] = b[i-1];\n }\n go(i, 0, n) {\n b[i] = 2 * b[i] - i + n + 1;\n r[i] = i; // Store indices\n }\n sort(r.begin(), r.begin() + n + 1, cmp); // Sort using the comparator 'cmp'\n go(i, 0, n) {\n int pos = lower_bound(r.begin(), r.begin() + n + 1, b[i], [&](int idx, int val) { return b[idx] < val; }) - r.begin();\n Ans += fenwick_query(pos);\n fenwick_update(pos + 1, 1);\n }\n LL t = (1LL * n * (n + 1)) / 2;\n return Ans >= (t + 1) / 2;\n}\n\nint main() {\n ios::sync_with_stdio(0);\n cin.tie(0);\n cout.tie(0);\n\n cin >> n;\n int l = 1, r = n;\n go(i, 1, n){\n cin >> a[i];\n c[i] = a[i];\n }\n sort(c + 1, c + n + 1);\n int ans = 0;\n while(l <= r) {\n int mid = MID(l, r);\n if (find(mid)) {\n l = mid + 1;\n ans = c[mid];\n } else {\n r = mid - 1;\n }\n }\n cout << ans << '\\n';\n return 0;\n}"}