{"optimized_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Range {\npublic:\n    class Iterator {\n    public:\n        Iterator(int current) : current_value(current) {}\n        int operator*() const { return current_value; }\n        Iterator& operator++() { ++current_value; return *this; }\n        bool operator!=(const Iterator& other) const { return current_value != other.current_value; }\n    private:\n        int current_value;\n    };\n\n    Range(int start, int end) : start_value(start), end_value(end) {}\n    Iterator begin() const { return Iterator(start_value); }\n    Iterator end() const { return Iterator(end_value); }\nprivate:\n    int start_value, end_value;\n};\n\nint main() {\n    string s1, s2;\n    cin >> s1 >> s2;\n    int n = s1.size(), m = s2.size();\n\n    vector<int> dp(m + 1);\n\n    for (int i : Range(0, m + 1)) dp[i] = i;\n\n    for (int i : Range(1, n + 1)) {\n        int prev = i - 1; // Start with the previous row's factor for dp[i-1][0]\n        dp[0] = i; // Initialize dp[i][0] since i-1 to i cost 1 step insertion\n        for (int j : Range(1, m + 1)) {\n            int temp = dp[j]; // Store current dp[i-1][j]\n            if (s1[i - 1] != s2[j - 1])\n                dp[j] = min({prev + 1, dp[j] + 1, dp[j - 1] + 1}); // Apply the dp formula\n            else\n                dp[j] = min({prev, dp[j] + 1, dp[j - 1] + 1}); // Apply the dp formula with no change\n            prev = temp; // Move to the next state for dp[i-1][j-1]\n        }\n    }\n\n    cout << dp[m] << endl;\n    return 0;\n}\n"}