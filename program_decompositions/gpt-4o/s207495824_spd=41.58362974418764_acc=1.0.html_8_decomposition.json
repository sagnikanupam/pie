{"optimized_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n\nconst int MAXN = 200005;\n\nint n, nn;\nint a[MAXN];\nll sum[MAXN];\n\ninline int read() {\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) {\n        if (ch == '-') f = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch)) {\n        x = (x << 3) + (x << 1) + ch - '0'; // x = x * 10 + ch - '0'\n        ch = getchar();\n    }\n    return x * f;\n}\n\ninline void update(int x, int d) {\n    for (; x <= nn; x += x & -x) sum[x] += d;\n}\n\ninline ll query(int x) {\n    ll ans = 0;\n    for (; x > 0; x -= x & -x) ans += sum[x];\n    return ans;\n}\n\ninline ll chk(int k) {\n    ll ans = 0;\n    int shift = n;\n    fill(sum, sum + 2 * MAXN, 0);\n    nn = 2 * n; // Adjusted array size to avoid need for sort/unique operations\n    update(shift, 1); // Start with index shift for prefix sum = 0\n\n    int prefix = 0;\n    for (int i = 1; i <= n; ++i) {\n        prefix += (a[i] <= k) ? 1 : -1;\n        ans += query(prefix + shift - 1);\n        update(prefix + shift, 1);\n    }\n\n    return ans;\n}\n\nint main() {\n    n = read();\n    int mi = INT_MAX, mx = INT_MIN;\n    for (int i = 1; i <= n; ++i) {\n        a[i] = read();\n        mi = min(mi, a[i]);\n        mx = max(mx, a[i]);\n    }\n\n    int L = mi - 1, R = mx + 1, mid, ans;  // Optimal start conditions for L and R\n    ll lim = 1LL * n * (n + 1) / 4 + 1;\n\n    while (L + 1 < R) {  // Optimized binary search condition\n        mid = L + (R - L) / 2;  // More stable mid calculation\n        if (chk(mid) >= lim) {\n            ans = mid;\n            R = mid;\n        } else {\n            L = mid;\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"}