{"optimized_code": "/*\n \n Code By OptimizedProgrammer\n \n */\n \n #include <bits/stdc++.h>\n \n \n \n using namespace std;\n \n typedef long long ll;\n \n \n \n // Fast input\n \n inline void read(int &x){\n \n     x = 0; int ne = 0; char c;\n \n     while(!isdigit(c = getchar()) && c != '-');\n \n     if(c == '-') { ne = 1; c = getchar(); }\n \n     x = c - '0';\n \n     while(isdigit(c = getchar())) x = x * 10 + c - '0';\n \n     if(ne) x = -x;\n \n }\n \n \n \n const int maxn = 200005;\n \n ll bit[maxn];\n \n \n \n // Binary Indexed Tree functions\n \n inline void update(int x){\n \n     while(x < maxn){\n \n         bit[x]++;\n \n         x += x & -x;\n \n     }\n \n }\n \n \n \n inline ll query(int x){\n \n     ll res = 0;\n \n     while(x > 0){\n \n         res += bit[x];\n \n         x -= x & -x;\n \n     }\n \n     return res;\n \n }\n \n \n \n int main(){\n \n     ios::sync_with_stdio(false);\n \n     cin.tie(0);\n \n     \n \n     int n;\n \n     read(n);\n \n     vector<int> a(n + 1);\n \n     int mi = INT32_MAX, mx = INT32_MIN;\n \n     for(int i = 1; i <= n; i++){\n \n         read(a[i]);\n \n         mi = min(mi, a[i]);\n \n         mx = max(mx, a[i]);\n \n     }\n \n \n \n     // Lambda function for checking\n \n     auto chk = [&](int k) -> ll {\n \n         vector<int> prefix(n + 1, 0);\n \n         for(int i = 1; i <= n; i++){\n \n             prefix[i] = prefix[i-1] + (a[i] <= k ? 1 : -1);\n \n         }\n \n \n \n         // Coordinate compression\n \n         vector<int> sorted = prefix;\n \n         sort(sorted.begin(), sorted.end());\n \n         sorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n \n \n \n         // Reset BIT\n \n         fill(bit, bit + maxn, 0);\n \n         ll ans = 0;\n \n         // Initial prefix sum\n \n         prefix[0] = lower_bound(sorted.begin(), sorted.end(), prefix[0]) - sorted.begin() + 1;\n \n         update(prefix[0]);\n \n \n \n         for(int i = 1; i <= n; i++){\n \n             prefix[i] = lower_bound(sorted.begin(), sorted.end(), prefix[i]) - sorted.begin() + 1;\n \n             ans += query(prefix[i] - 1);\n \n             update(prefix[i]);\n \n         }\n \n         return ans;\n \n     };\n \n \n \n     ll lim = 1LL * n * (n + 1) / 4 + 1;\n \n     int L = mi, R = mx, ans_val = mx;\n \n     while(L <= R){\n \n         int mid = L + (R - L) / 2;\n \n         if(chk(mid) >= lim){\n \n             ans_val = mid;\n \n             R = mid - 1;\n \n         }\n \n         else{\n \n             L = mid + 1;\n \n         }\n \n     }\n \n     printf(\"%d\\n\", ans_val);\n \n     return 0;\n \n }\n"}